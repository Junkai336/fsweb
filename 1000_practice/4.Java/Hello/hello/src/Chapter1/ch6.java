public class ch6 {

}

/*
 * 객체지향프로그래밍
 * - 객체를 먼저 만들고 객체를 하나씩 조립해서 완성된 프로그램을 만드는 기법
 * 
 * 객체지향프로그래밍 특징
 * - 캡슐화
 * - 객체의 데이터(필드), 동작(메소드)를 하나로 묶고 실제 구현 내용을 외부에 감추는 것
 * - 외부 객체는 객체 내부 구조를 알지 못함.
 * - 객체가 노출해서 제공하는 필드와 메소드만 이용 가능
 * - 외부의 잘못된 사용으로 인해 객체가 손상되지 않기 위함
 * - 접근제한자: 캡슐화된 멤버를 노출시킬것인지 숨길것인지 결정
 * - 상속
 * - 객체지향프로그래밍에선 부모 역할의 상위 객체와 자식 역할의 하위 객체가 있다.
 * - 부모 객체의 필드와 메소드를 자식 객체에게 물려주어 사용할 수 있게 함
 * - 다형성
 * - 사용 방법은 동일하지만 실행 결과가 다양하게 나오는 성질
 * 객체
 * - 다른 것과 식별이 가능한 것
 * - 속성(필드)과 동작(메소드)으로 구성
 * - 다른 객체와 서로 상호작용하면서 동작
 * 
 * 객체 간의 관계
 * - 집합 관계 : 완성품과 부품 관계
 * - 사용 관계 : 다른 객체의 필드를 읽고 변경하거나 메소드를 호출하는 관계
 * - 상속 관계 : 부모와 자식의 관계, 물려받는 관계
 * 
 * 객체 생성
 * - new 클래스()
 * - 클래스 변수 = new 클래스(매개값1, 매개값2, ...);
 * - 객체를 생성한 후 연이어 생성자를 호출해서 객체를 초기화
 * - 객체 초기화: 필드 초기화 or 메소드 호출해서 객체를 사용할 준비를 하는 것
 * - ex) Student s1 = new Student; (Student = 가져오려는 클래스명)
 * 
 * 클래스
 * - 객체를 만들어내기 위한, 객체를 정의하기 위한 일종의 설계도
 * - 객체를 생성하려면 설계도에 해당하는 클래스가 필요
 * - public class : 공개 클래스 선언
 * - 클래스명 : 첫문자 대문자, 캐멀스타일, $, _ 포함 가능
 * - 하나의 소스 파일은 복수 개의 클래스 선언 포함 가능
 * - 구성 멤버: 필드, 셍성자, 메소드
 * 
 * 클래스의 용도
 * - 실행 클래스: main() 메소드를 가지고 있는 실행 클래스
 * - 라이브러리 클래스: 실행할 수 없으며 다른 클래스에서 이용하는 클래스
 * 
 * 공개 클래스
 * - 어느 위치에 있든지 패키지와 상관없이 사용할 수 있는 클래스
 * - 복수 개의 클래스 선언할 때 소스 파일명과 동일한 클래스만 공개 클래스로 선언 가능
 * - 복수 개의 클래스를 공개 클래스로 선언하고 싶다면, 소스 파일을 별도로 생성해야 함 (그러니까 클래스 이름이 파일명과 동일해야 함)
 * 
 * 인스턴스
 * - 클래스로부터 생성된 객체
 * - 인스턴스화 : 클래스로부터 객체를 만드는 과정
 * 
 * 메소드
 * - 객체들 사이의 상호작용 수단
 * - 객체가 다른 객체의 기능을 이용할 때 메소드를 호출
 * - 객체가 수행할 동작으로 호출 시 실행하는 블록
 * - 메소드 선언: ex) int method() { ... }
 * 
 * 메소드 호출
 * - 메소드 호출: 메소드(매개값1, 매개값2)
 * - 전달하고자 하는데이터를 매개값에 기술.
 * - 매개값은 메소드가 실행할 때 필요한 값.
 * - 리턴값은 메소드의 실행의 결과, 호출한 곳으로 돌려주는 값
 * - 메소드의 리턴값은 호출한 곳에서 변수로 대입 받아 사용 (ex) int result = add(10,20))
 * 
 * 생성자
 * - 객체 생성시 초기화 역할
 * - 리턴 타입이 없고 이름은 클래스 이름과 동일
 * - 생성자 선언 : 클래스(매개변수, ...) { ... }
 * - 메소드와 달리 리턴 타입이 존재하지 않는다.
 * - 클래스 이름과 동일하다.
 * - 모든 클래스는 생성자가 존재, 하나 이상 가질 수 있다. (클래스에 생성자 선언이 없으면 컴파일러가 자동으로 기본 생성자 추가)
 * - 기본 생성자 : [public] 클래스() { ... }
 * - 클래스 변수 = new <클래스(); <- 기본생성자 호출>
 * - 매개 변수 대입 받기
 * - 클래스 변수 = new 클래스(매개값1, 매개값2, 매개값3)
 * - 클래스(타입 매개값1, 타입 매개값2, 타입 매개값3) { ... }
 * - 생성자의 매개값은 new 연산자로 생성자를 호출할 때 주어진다.
 * 
 * this
 * - 매개변수명이 필드명과 동일하다면, 필드임을 구분하기 위해 this 키워드를 붙인다.
 *      ex) public korean(Strng name) {
 *      this.name = name;
 *      }
 * - this : 현재 객체를 의미
 * 
 * 생성자 오버로딩
 *  - 매개변수가 다른 생성자를 여러개 선언하는 것
 *  - 매개변수의 타입, 개수, 순서가 다르게 여러 개의 생성자 선언
 *  - 매개값으로 객체의 필드를 다양하게 초기화하기 위함.
 *      ex) public class car {
 *          car() {}
 *          car(string model) {}
 *          car(string model, string color) {}
 * 
 *          Car car1 = new Car();
 *          Car car2 = new Car("모델명");
 *          Car car3 = new Car("모델명", "색깔");
 * }
 * 
 * 필드
 * - 객체의 데이터 저장
 * - 필드명: 첫문자 소문자 , 캐멀스타일
 * - 선언 방법은 변수 선언과 동일, 반드시 클래스 블록에서 선언되어야 한다.
 * - 필드 선언 : ex) int field;
 * 타입 필드명;
 * 타입 필드명 = 초기값;
 * - 객체 내부의 생성자와 메소드 내부에서 사용 가능
 * - 객체 외부에서는 참조 변수와 도트(.) 연산자를 이용해서 필드를 읽고 변경해야 한다.
 * 
 * 객체 접근 연산자(.) : 객체가 가지고 있는 필드나 메소드에 접근하고자 할 때 참조 변수 뒤에 붙임 (ex: myCar.speed =
 * 60;) (읽기: println: 참조변수.필드명)
 * 
 * 필드 / 로컬변수
 * 생성위치: 클래스 선언 블록 / 생성자, 메소드 선언 블록
 * 존재위치: 객체 내부 / 생성자, 메소드 호출 시에만 존재
 * 사용위치: 객체 내,외부 / 생성자, 메소드 블록 내부에서만 사용
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 */