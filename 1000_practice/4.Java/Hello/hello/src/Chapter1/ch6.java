public class ch6 {

}

/*
 * 객체지향프로그래밍
 * - 객체를 먼저 만들고 객체를 하나씩 조립해서 완성된 프로그램을 만드는 기법
 * 
 * 객체지향프로그래밍 특징
 * - 캡슐화
 * - 객체의 데이터(필드), 동작(메소드)를 하나로 묶고 실제 구현 내용을 외부에 감추는 것
 * - 외부 객체는 객체 내부 구조를 알지 못함.
 * - 객체가 노출해서 제공하는 필드와 메소드만 이용 가능
 * - 외부의 잘못된 사용으로 인해 객체가 손상되지 않기 위함
 * - 접근제한자: 캡슐화된 멤버를 노출시킬것인지 숨길것인지 결정
 * - 상속
 * - 객체지향프로그래밍에선 부모 역할의 상위 객체와 자식 역할의 하위 객체가 있다.
 * - 부모 객체의 필드와 메소드를 자식 객체에게 물려주어 사용할 수 있게 함
 * - 다형성
 * - 사용 방법은 동일하지만 실행 결과가 다양하게 나오는 성질
 * 객체
 * - 다른 것과 식별이 가능한 것
 * - 속성(필드)과 동작(메소드)으로 구성
 * - 다른 객체와 서로 상호작용하면서 동작
 * 
 * 객체 간의 관계
 * - 집합 관계 : 완성품과 부품 관계
 * - 사용 관계 : 다른 객체의 필드를 읽고 변경하거나 메소드를 호출하는 관계
 * - 상속 관계 : 부모와 자식의 관계, 물려받는 관계
 * 
 * 객체 생성
 * - new 클래스()
 * - 클래스 변수 = new 클래스(매개값1, 매개값2, ...);
 * - 객체를 생성한 후 연이어 생성자를 호출해서 객체를 초기화
 * - 객체 초기화: 필드 초기화 or 메소드 호출해서 객체를 사용할 준비를 하는 것
 * - ex) Student s1 = new Student(); (Student = 가져오려는 클래스명)
 * 
 * 클래스
 * - 객체를 만들어내기 위한, 객체를 정의하기 위한 일종의 설계도
 * - 객체를 생성하려면 설계도에 해당하는 클래스가 필요
 * - public class : 공개 클래스 선언
 * - 클래스명 : 첫문자 대문자, 캐멀스타일, $, _ 포함 가능
 * - 하나의 소스 파일은 복수 개의 클래스 선언 포함 가능
 * - 구성 멤버: 필드, 셍성자, 메소드
 * 
 * 클래스의 용도
 * - 실행 클래스: main() 메소드를 가지고 있는 실행 클래스
 * - 라이브러리 클래스: 실행할 수 없으며 다른 클래스에서 이용하는 클래스
 * 
 * 공개 클래스
 * - 어느 위치에 있든지 패키지와 상관없이 사용할 수 있는 클래스
 * - 복수 개의 클래스 선언할 때 소스 파일명과 동일한 클래스만 공개 클래스로 선언 가능
 * - 복수 개의 클래스를 공개 클래스로 선언하고 싶다면, 소스 파일을 별도로 생성해야 함 (그러니까 클래스 이름이 파일명과 동일해야 함)
 * 
 * 인스턴스
 * - 클래스로부터 생성된 객체
 * - 인스턴스화 : 클래스로부터 객체를 만드는 과정
 * 
 * 메소드
 * - 객체들 사이의 상호작용 수단
 * - 객체가 다른 객체의 기능을 이용할 때 메소드를 호출
 * - 객체가 수행할 동작으로 호출 시 실행하는 블록
 * - 메소드 선언: 객체의 동작을 실행 블록으로 정의
 *                ex) int method() { ... } : 객체의 동작을 실행 블록으로 정의.
 * -              리턴타입 메소드명 (매개변수, ...) { ... }
 * - 리턴타입: 메소드 실행 후 호출한 곳으로 전달하는 결과값의 타입
 * - void : 리턴타입이 없는 경우
 * - 리턴타입이 있는 경우 반드시 리턴값을 지정해야 한다. (return 변수명)
 * 
 * 
 * 메소드 호출
 * - 실행블록을 실제로 실행하는 것(객체내부에서, 다른객체에서)
 * - 메소드 호출: 메소드(매개값1, 매개값2)
 * - 전달하고자 하는 데이터를 매개값에 기술.
 * - 매개값은 메소드가 실행할 때 필요한 값. 메소드가 실행할 때 필요한 매개값을 전달받기 위한 변수
 * - 리턴값은 메소드의 실행의 결과, 호출한 곳으로 돌려주는 값
 * - 메소드의 리턴값은 호출한 곳에서 변수로 대입 받아 사용 (ex) int result = add(10,20))
 * - 다른 객체에서 메소드를 호출하려면,
 *      - 리턴타입이 있을 경우?: 타입 변수 = 메소드();
 *      - Calculator calc = method2(); <- 이런식인가???
 *          void method1() {
 *              Calculator calc = new Calculator();
 *              calc.method2();         
 *          }
 * 
 * 메소드명
 * - 첫문자 소문자, 캐멀스타일
 * 
 * 메소드 오버로딩
 * - 메소드 이름은 같되 매개변수의 타입, 개수, 순서가 다른 메소드를 여러개 선언하는 것
 * - 다양한 매개값을 처리하기 위함.
 * - 리턴타입 메소드명 (타입 매개변수, ...)
 *     무관     동일     타입 or 개수 or 순서가 달라야 함
 * ex) int plus (int x, int y) {int result = x + y; return result;}
 * ex) double plus (double x, double y) {double result = x + y; return result;}
 * ex) double areaRectangle(double width) {return width * width;}
 * ex) double areaRectangle(double width, double height) {return width * height;}
 * 
 * 매개변수
 * - 메소드를 호출할 때 전달한 매개값을 받기 위해 사용.
 * 
 * 가변길이 매개변수
 * - 매개변수의 개수와 상관없이 매개값을 줄 수 있음.
 * - 매개값들은 자동으로 배열 항목으로 변환되어 메소드에서 사용.
 * - 메소드 호출시 직접 배열을 매개값으로 제공할 수 있음.
 * - 타입 메소드명(타입 ... 매개변수명?) {}
 * - int sum(int ... values) {}
 * - -> int result = sum(1,2,3,4,5) or sum(1,2,3,4,5,6,7)...
 * 
 * - -> int[] values = { 1, 2, 3, 4, 5}
 * - -> int result = sum(values);
 * 
 * - -> int result = sum(new int[] {1,2,3})
 * 
 * - -> values(매개변수명)은 배열 타입의 변수처럼 활용
 * - -> for (int i = 0; i < values.length; i++) {sum += values[i]}
 * 
 * return
 * - return [리턴값];
 * - 메소드의 실행을 강제종료하고 호출한 곳으로 돌아간다.
 * - return문 이후 실행문을 작성하면 컴파일 에러(Unreachable code)
 * - return문 이후의 실행문은 결코 실행되지 않는다.
 * - return false : 뒤에 실행문을 작성하더라도 메소드 즉시 종료? <- 아닌거같음 그냥 false 값을 반환한다
 * 
 * 생성자
 * - 객체 생성시 초기화 역할
 * - 리턴 타입이 없고 이름은 클래스 이름과 동일
 * - 생성자 선언 : 클래스(매개변수, ...) { ... }
 * - 메소드와 달리 리턴 타입이 존재하지 않는다.
 * - 클래스 이름과 동일하다.
 * - 모든 클래스는 생성자가 존재, 하나 이상 가질 수 있다. (클래스에 생성자 선언이 없으면 컴파일러가 자동으로 기본 생성자 추가)
 * - 기본 생성자 : [public] 클래스() { ... }
 * - 클래스 변수 = new <클래스(); <- 기본생성자 호출>
 * - 매개 변수 대입 받기
 * - 클래스 변수 = new 클래스(매개값1, 매개값2, 매개값3)
 * - 클래스(타입 매개값1, 타입 매개값2, 타입 매개값3) { ... }
 * - 생성자의 매개값은 new 연산자로 생성자를 호출할 때 주어진다.
 * 
 * this
 * - 매개변수명이 필드명과 동일하다면, 필드임을 구분하기 위해 this 키워드를 붙인다.
 *      ex) public korean(Strng name) {
 *      this.name = name;
 *      }
 * - this : 현재 객체를 의미
 * 
 * 생성자 오버로딩
 *  - 매개변수가 다른 생성자를 여러개 선언하는 것
 *  - 매개변수의 타입, 개수, 순서가 다르게 여러 개의 생성자 선언
 *  - 매개값으로 객체의 필드를 다양하게 초기화하기 위함.
 *      ex) public class car {
 *          car() {}
 *          car(string model) {}
 *          car(string model, string color) {}
 * 
 *          Car car1 = new Car();
 *          Car car2 = new Car("모델명");
 *          Car car3 = new Car("모델명", "색깔");
 * }
 * 
 * this()
 *  - 같은 클래스의 다른 생성자를 호출할 때 사용한다.
 *  - 밑에 생성자들은 this()를 통해 모두 Car(String model, String color, int maxSpeed) 를 호출하고 있는 것
 * 
 * 다른 생성자 호출
 *  - 생성자 오버로딩시 중복코드 제거를 위해 생성자(매개값 최대치)의 객체 초기화 코드를 하나만 두고, 타 생성자가 this(매개값최대치) 로 다른 생성자를 호출할 수 있음.
 *      Car(String model) {
 *          this(model, 2, 3)
 *         }
 *      Car(String model, String Color) {
 *          this(model, 2, 3)
 *         }
 *      Car(String model, String Color, int maxSpeed) {
 *          this.model = model;
 *          this.color = color;
 *          this.maxSpeed = maxSpeed;
 *          (공통 초기화 코드)
 *         }
 * 
 * 필드
 * - 객체의 데이터 저장
 * - 필드명: 첫문자 소문자 , 캐멀스타일
 * - 선언 방법은 변수 선언과 동일, 반드시 클래스 블록에서 선언되어야 한다.
 * - 필드 선언 : ex) int field;
 * 타입 필드명;
 * 타입 필드명 = 초기값;
 * - 객체 내부의 생성자와 메소드 내부에서 사용 가능
 * - 객체 외부에서는 참조 변수와 도트(.) 연산자를 이용해서 필드를 읽고 변경해야 한다.
 * 
 * 객체 접근 연산자(.) : 객체가 가지고 있는 필드나 메소드에 접근하고자 할 때 참조 변수 뒤에 붙임 (ex: myCar.speed =
 * 60;) (읽기: println: 참조변수.필드명)
 * 
 * 필드 / 로컬변수
 * 생성위치: 클래스 선언 블록 / 생성자, 메소드 선언 블록
 * 존재위치: 객체 내부 / 생성자, 메소드 호출 시에만 존재
 * 사용위치: 객체 내,외부 / 생성자, 메소드 블록 내부에서만 사용
 * 
 * 인스텐스 멤버 (필드, 메소드)
 * - 객체에 소속된 멤버
 * - 객체를 생성해야만 사용할 수 있는 멤버
 * 
 * 정적 멤버 (필드, 메소드)
 * - 클래스에 고정된 멤버
 * - 객체 없이도 사용할 수 있는 멤버
 * - 객체마다 가지고 있을 필요성이 없는 공용적인 필드는 정적 필드로 선언하는 것이 좋다.
 * - 인스턴스 필드를 이용하지 않는 메소드는 정적 메소드로 선언하는 것이 좋다.
 * - static 타입 필드 (= 초기값)
 * - static 리턴타입 메소드 (매개변수) {}
 * - 객체참조변수로도 접근 가능 / 클래스이름으로 접근하는 것이 정석(클래스이름.정적멤버) [인스턴스는 객체참조변수로, 정적멤버는 클래스로 접근]
 * - 객체가 없어도 실행된다는 특징 때문에 내부 인스턴스 필드, 인스턴스 메소드, this 를 사용할 수 없다.
 * - 정적 메소드, 정적 블록에서 인스턴스 멤버를 사용하고 싶다면 객체 생성 후 참조 변수로 접근 (main() 메소드도 static이기 때문에 객체 생성 후 참조변수로 접근)
 * 
 * 정적 블록
 * - 정적 필드는 선언과 동시에 초기값을 주는 것이 일반적이나 복잡한 초기화 작업이 필요할 경우 정적블록 사용
 * - 클래스가 메모리로 로딩될 때 자동으로 실행
 * - 정적 필드는 생성자에서 초기화 작업을 하지 않는다. 정적필드는 객체 생성 없이도 사용할 수 있고 생성자는 객체 생성 후 실행되기 때문
 * - statc { ... }
 * 
 * final 필드
 * - final 타입 필드명 [= 초기값;]
 * - 값을 변경하지 않고 읽기만 허용할 때 사용
 * - 초기값이 저장되면 최종적인 값이 되어 변경 불가
 * - 1. 필드 선언 시 초기값 대입
 * - 2. 복잡한 초기화 코드가 필요할 경우 생성자에서 초기값 대입
 * 
 * 상수
 * - final static 타입 필드명 [= 초기값;]
 * - 원주율같은 불변의 값 저장
 * - 초기값은 선언 시에 주거나 복잡한 초기화 코드가 필요한 경우 정적 블록에서 초기화
 * - 클래스명.필드명 으로 접근
 * - 이름은 전부 대문자, _ 로 작성
 * 
 * 패키지
 * - 디렉토리 + 클래스 식별 용도로 사용
 * - 주로 도메인 이름 역순으로 만든다. (com.mycompany)
 * - 상위패키지와 하위패키지를 도트(.)으로 구분
 * - 항상 소스 파일 최상단에 위치
 * - package 상위패키지.하위캐피키지;
 * - 패키지 이름은 소문자로 작성하는 것이 관례
 * 
 * import문
 * - 다른 패키지에 있는 클래스를 사용하기 위함
 * - import 상위패키지.하위패키지.해당클래스이름;
 * - import 상위패키지.하위캐피키지.*;
 * - 패키지 선언과 클래스 선언 사이 작성
 * - 하위패키지를 포함하지 않고 해당패키지만 포함한다
 * - 다른 패키지의 같은 이름의 클래스를 사용할 경우 정확히 어떤 패키지의 클래스를 사용하는지 명시.
 * - com.hankook.Tire tire = new com.hankook.Tire();
 * 
 * 접근제한자
 * - public : 클래스, 필드, 생성자, 메소드 /        제한범위: 없음                      <- 다른 패키지에서도 사용할 수 있음
 * - protected : 필드, 생성자, 메소드 /             제한범위: 같은 패키지 or 자식 객체
 * - default : 클래스, 필드, 생성자, 메소드 /       제한범위: 같은 패키지               <- 다른 패키지에서는 사용할 수 없음 (다른 패키지에서는 import 해도 사용 못하는 거임)
 * - private : 필드, 생성자, 메소드 /               제한범위: 객체 내부
 * 
 * - 클래스: public, default 접근 제한을 가질 수 있다.
 * - 생성자: public, default, private 접근 제한을 가질 수 있다.
 *      - public : 모든 패키지에서 객체를 생성할 수 있다. = 생성자를 호출할 수 있다.
 *      - default : 같은 패키지에서 객체를 생성할 수 있다.
 *      - private : 클래스 내부에서만 객체를 생성할 수 있다.
 * - 필드, 메소드: public, default, private 접근 제한을 가질 수 있다.
 * 
 * Getter Setter
 * - 직접적인 외부에서의 필드 접근을 막고 메소드를 통해 필드에 접근
 * - 메소드는 데이터를 검증해서 유효한 값만 필드에 저장할 수 있기 때문
 * 
 * 싱글톤 패턴
 * - 단 한개의 객체만 생성해서 사용하고 싶을 때 적용
 * - 생성자를 private 접근 제한해서 외부에서 new 연산자로 생성자를 호출할 수 없도록 하는 것
 * 
 * - private static 클래스 singleton = new 클래스()
 * - private 클래스명() {}
 * - public static 클래스 getInstance() {
 *        return singleton;
 *      }
 * 
 * 
 * - 필드선언은 생성자,메소드 앞 뒤 어디서든 ok
 * - 생성자 실행없이 클래스로부터 객체 만들 수 없음
 * - 인스턴스 필드는 정적 블록에서 초기화될 수 없다.
 * - 
 */