public class ch7 {
    
}

/* 
 * 상속
 *  - 부모 클래스의 필드와 메소드를 자식 클래스에게 물려주는 것
 *  - 이미 개발된 클래스를 재사용해서 새로운 클래스를 만들기 때문에 중복 코드를 줄인다.
 *  - 부모 클래스를 수정하면 모든 자식 클래스에 수정 효과를 가져온다.
 * 
 * 클래스 상속
 *  - public class 자식클래스명 extends 부모클래스명 {}
 *  - 자바는 다중 상속을 허용하지 않는다. extends 뒤에는 하나의 부모클래스만 와야 한다.
 * 
 * 부모 생성자 호출
 * - 부모있는 자식 객체 생성 -> 부모,자식 클래스 생성
 * - 모든 객체는 생성자를 호출해야만 생성된다.
 * - 자식 생성자 호출 시 숨겨져 있는 super()에 의해 부모 생성자가 호출된다.
 * - super() : 부모생성자 호출, 컴파일에서 자동 추가 (기본 생성자)
 * - super(매개값) : 부모에 매개변수를 갖는 생성자만 있다면 매개값의 타입과 개수가 일치하는 부모 생성자를 호출해야 한다.
 * public 자식클래스() {
 *  super() or super(매개값) or [super()]
 * }
 * 
 * 메소드 오버라이딩
 * - 부모클래스의 메소드가 자식클래스가 사용하기에 적합하지 않은 경우 재정의해서 사용할 수 있다.
 * - 규칙
 *  - 부모 메소드의 선언부(리턴타입, 메소드이름, 매개변수) 동일해야 한다.
 *  - 접근제한을 더 강하게 오버라이딩 할 수 없다.
 *  - 새로운 예외를 throws 할 수 없다.
 *  
 * @Override 
 *  - 어노테이션
 *  - 컴파일시 정확히 오버라이딩이 되었는지 체크해줌 (문제가 있다면 컴파일 에러 출력) 
 *  - 생략가능
 * 
 * super.method()
 *  - 재정의시, 부모 메소드는 숨겨지고 자식 메소드만 사용되기 때문에 부모 메소드의 일부만 변경된다 하더라도 중복된 내용을 자식 메소드도 가지고 있어야 한다.
 *    부모 메소드가 100줄의 코드를 가지고 있을 경우 자식 메소드에서 1줄만 추가하고 싶어도 100줄의 코드를 자식 메소드에서 다시 작성해야 한다.
 *  - 자식 메소드 내에서 숨겨진 부모 메소드를 호출한다.
 *  - super.메소드명()
 * 
 * final 클래스
 *  - 더이상 상속할 수 없는 클래스
 *  - 부모가 될 수 없어 자식 클래스를 만들 수 없다.
 *  - public final class 클래스명 () {}
 * 
 * final 메소드
 *  - 오버라이딩할 수 없는 메소드
 *  - public final 리턴타입 메소드 () {}
 * 
 * protected 접근 제한자
 *  - 필드, 생성자, 메소드
 *  - 같은 패키지 혹은 다른 패키지에서 자식 객체만 사용 가능
 *  - 다른 패키지에 있는 자식은 부모를 new 연산자로 생성자를 직접 호출할 수 없고, 자식 생성자에서 super()로 A 생성자를 호출할 수 있다. 
 * 
 * 타입 변환
 *  - 클래스의 타입 변환은 상속 관계에 있는 클래스 사이에서 발생
 * 
 * 자동 타입 변환
 *  - 자동적으로 타입 변환이 일어나는 것
 *  - 부모타입 참조변수 = 자식타입객체;
 *        Cat cat = new Cat();
 *  - ex) Animal animal = cat;
 *  - -> cat == animal 은 true
 * 
 *  - ex) Animal animal = new Cat;
 * 
 *  - 자식 객체를 부모에 담는다.
 *  - 자식객체와 부모변수는 타입만 다를 뿐 동일한 Cat 객체를 참조한다.
 * 
 *  - 부모 타입으로 자동 타입 변환된 경우 "부모 클래스에 선언된 필드와 메소드만 접근이 가능하다."
 *  - 즉, 변수는 자식 객체를 참조하지만 변수로 접근 가능한 멤버는 부모클래스 멤버로 한정된다.
 *  - 단, 자식에서 오버라이딩된 메소드가 있다면, 부모 메소드 대신 오버라이딩된 메소드가 호출된다.
 * 
 * 강제 타입 변환
 *  - 부모타입은 자식 타입으로 자동 변환 되지 않는다.
 *  - 캐스팅 연산자로 강제 타입 변환을 할 수 있다.
 *  - 자식타입 참조변수 = (자식타입) 부모타입객체;
 *      Cat cat = (Cat) Animal;
 * 
 *  - 이게 아마 부모타입으로 자동변환 후 자식타입으로 다시 쓰고 싶을 때 사용하는 건가 싶음.. 강제타입변환은 잘 모르겠음
 * 
 * 다형성
 *  - 사용 방법은 동일하지만 실행 결과가 다양하게 나오는 것 = 동일한 메소드를 가지고 있다는 것
 *  - 상속과도 관련이 있고 자동 타입 변환, 메소드 재정의가 필요하다.
 *  ex
 *  class Car { public Tire tire; , public void run() { tire.roll } }
 *  class Tire { public void roll() { "메시지"; } }
 *  class aTire extends Tire { public void roll() @Override { "메시지2" }}
 *  class bTire extends Tire { public void roll() @Override { "메시지3" }}
 * 
 *  Car myCar = new Car();
 *  
 *  myCar.tire = new Tire();
 *  myCar.tire = aTire();
 *  myCar.tire = bTire();
 * 
 *  mycar.run() 하면 다 다르게 나옴.
 * 
 * 매개변수 다형성
 *  - 메소드가 클래스 타입의 매개변수를가지고 있을 경우, 동일한 타입의 객체를 제공하거나 자식 객체를 제공하는 등 발생
 *  - 아마 객체의 메소드를 쓰려고 객체(클래스)를 매개변수로 받는 것일 거임. (오버라이딩이라든지)
 * 
 * 객체 타입 확인
 *  - 실제로 어떤 객체가 매개값으로 제공되었는지 확인하는 방법
 *  - 변수가 참조하는 객체의 타입 확인 (true, false)
 *  - boolean result = 객체 instanceof 타입
 *  - ex) if(parent instanceof Child)
 * 
 * 추상클래스
 * - 클래스들의 공통적인 필드나 메소드를 추출해서 선언한 클래스
 * - 추상클래스는 실체 클래스의 부모 역할을 한다. (실체 클래스는 추상 클래스를 상속해서 공통적인 필드나 메소드를 물려받을 수 있다.)
 * - 추상클래스는 실체 클래스의 공통되는 필드와 메소드를 추출해서 만들었기 때문에 new 연산자를 사용해서 객체를 직접 생성할 수 없다. 상속을 통해 자식 클래스만 만들 수 있다.
 * - 추상클래스는 새로운 실체 클래스를 만들기 위한 부모 클래스로만 사용된다.
 * - extends 뒤에만 올 수 있다.
 * - public abstract class 클래스명 { 필드, 생성자, 메소드 ... }
 * - 추상클래스도 자식 객체 생성시 super()로 생성자가 호출되기 때문에 생성자가 반드시 있어야 한다.
 * - 객체 생성없이 마음대로 뽑아 쓰는게 point 인듯함
 * 
 * 추상메소드
 * - 추상클래스는 추상메소드를 선언할 수 있다.
 * - abstract 리턴타입 메소드명()
 * - 중괄호 블록, 실행 내용을 가지지 않는다.
 * - 실행내용은 자식 클래스에서 반드시 오버라이딩해서 실행 내용을 채워야 한다.
 * 
 * 
 * 
 * 
 */