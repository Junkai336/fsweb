package Chapter1;

public class ch8 {
    
}

/* 
 * 인터페이스
 *  - 두 객체를 연결하는 역할
 *  - 객체A는 인터페이스를 통해 객체B를 사용할 수 있다. 
 *  - 다형성 구현에 주된 기술로 이용
 *  - public interface 인터페이스명 {}
 *  - 인터페이스도 하나의 타입이므로 변수의 타입으로 사용할 수 있다. (참조 타입) (객체를 참조하고 있지 않다는 뜻으로 null을 대입할 수 있다.)
 *  - RemoteControl rc;
 *  - 인터페이스 참조변수 = null;
 * 
 * 구현 클래스
 *  - 객체A가 인터페이스의 추상 메소드를 호출하면, 인터페이스는 객체 B의 메소드를 실행 (오버라이딩 메소드를 가지고 있어야 함)
 *  - 객체B를 인터페이스를 구현(implement)한 객체라고 한다.
 *  - public class B implements 인터페이스명 {}
 *  - implements 키워드 : 해당 클래스가 인터페이스를 통해 사용할 수 있다는 표시, 인터페이스의 추상 메소드를 재정의한 메소드가 있다는 뜻
 *  - 구현 클래스는 모든 추상 메소드를 재정의해서 실행 코드를 가져야 한다.
 * 
 * 대입
 *  - 인터페이스 참조변수 = new 구현클래스();
 *  - 참조변수.메소드(); -> 구현클래스에서 오버라이딩 된 메소드 출력
 *  - 인터페이스 변수는 참조 타입이기 때문에 구현 객체가 대입되면 구현 객체의 번지를 저장한다.
 * 
 * 상수 필드
 *  - 인터페이스는 불변의 상수 필드를 멤버로 가질 수 있다.
 *  - [public static final] 타입 필드명 = 값;
 *  - 인터페이스에 선언된 필드는 모두 public static final 특성을 갖는다. 때문에 자동으로 컴파일 과정에서 붙게 된다.
 *  - 상수명은 대문자로 작성, 연결 문자는 _
 * 
 * 추상 메소드
 * - 인터페이스는 구현 클래스가 재정의해야 하는 public 추상 메소드를 멤버로 가질 수 있다.
 * - 리턴타입, 메소드명, 매개변수만 기술하고 중괄호 {}는 붙이지 않는다.
 * - [public abstract] 리턴타입 메소드명(매개변수);
 * - public abstract를 생략하더라도 컴파일 과정에서 자동으로 붙게 된다.
 * - 구현 클래스에서 추상 메소드를 재정의할 때 public 보다 낮은 접근 제한으로 재정의 할 수 없다.
 * 
 * 디폴트 메소드
 *  - 인터페이스에 선언하는 완전한 실행 코드를 가진 메소드
 *  - [public] default 리턴타입 메소드명() { ... }
 *  - 상수필드를 읽거나 추상메소드를 호출하는 코드를 작성할수 있다.
 *  - 구현 객체가 필요한 메소드. (구현 객체에 추가할 것이 있으면 쓰는 용도인듯?) (메소드 오버라이딩시 재정의 가능, 이때는 default 뺌)
 * 
 * 정적 메소드
 *  - 구현 객체가 없어도 인터페이스만으로 호출할 수 있다.
 *  - [public || private] static 리턴타입 메소드명() { ... }
 *  - public은 생략하더라도 컴파일 과정에서 자동으로 붙는다.
 *  - 인터페이스.정적메소드명();
 * 
 * private 메소드
 *  - 상수필드,추상메소드,디폴트메소드,정적메소드는 모두 public 접근 제한을 갖고 생략하더라도 컴파일 과정에서 자동으로 붙는다.
 *  - private 메소드는 디폴트 메소드 안에서만 호출이 가능하다.
 *  - private static 메소드는 정적 메소드 안에서도 호출이 가능하다.
 *  - private 메소드의 용도 : 디폴트 메소드와 정적 메소드들의 중복 코드를 줄이기 위함
 * 
 * 다중 인터페이스
 *  - 구현 객체는 여러 개의 인터페이스를 implements 할 수 있다.
 *  - public class 구현클래스명 implements 인터페이스A, 인터페이스B { ... }
 *  - 구현 객체는 모든 인터페이스가 가진 추상 메소드를 재정의해야 한다.
 *  - 두 인터페이스 타입의 변수에 각각 대입될 수 있다.
 *  - 인터페이스A 참조변수 = new 구현클래스명();
 *  - 인터페이스B 참조변수 = new 구현클래스명();
 *  - 어떤 인터페이스 참조변수에 대입되느냐에 따라 변수를 통해 호출할수 있는 추상 메소드가 결정된다.
 * 
 * 인터페이스 상속
 *  - 인터페이스는 다중 상속을 허용한다.
 *  - public interface 자식인터페이스명 extends 부모인터페이스1, 부모인터페이스2 { ... }
 *  - 자식인터페이스 변수 = new 구현클래스(); => 전부 호출
 *  - 부모인터페이스1 변수 = new 구현클래스(); => 부모만 호출
 * 
 * 자동타입변환
 *  - 인터페이스 변수 = 구현객체;
 *  - 상속이랑 매커니즘 같음
 * 
 * 강제타입변환
 *  - 구현클래스 변수 = (구현클래스) 인터페이스변수;
 *  - 상속이랑 매커니즘 같음
 * 
 * 다형성
 *  - 377p
 *  - 인터페이스.필드 = new 구현클래스(); <- 필드가 대입되는건가???
 * 
 * 
 * 객체타입확인
 *  - 객체 instanceof 타입
 *  - vehicle instanceof Bus : vehicle에 대입된 객체가 Bus일 경우에만~
 *  - 대입된 객체라는게 a <= b?
 */