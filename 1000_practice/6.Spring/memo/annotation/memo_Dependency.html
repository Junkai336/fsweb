<!-- 
    의존 관계 용어 정리

    스프링 컨테이너
        - 스프링 빈의 생명 주기를 관리
        - 스프링 빈에게 추가 기능 제공
        - 개발자는 new 연산자, 인터페이스 호출 등 방식으로 객체를 생성하고 소멸하지만, 스프링 컨테이너를 사용하면 그 역할을 대신 해준다.

    빈
        - ioC 컨테이너(스프링 컨테이너)가 관리하는 자바 객체(POJO)

    IoC(Inversion of Control)
        - 의존 관계를 만드는 책임을 사용자가 아니라 프레임워크로 옮기는 것
    
    와이어링
        - 애플리케이션 객체 간의 연관관계 형성

    의존 관계 주입
        - 빈 식별, 빈 생성, 와이어링 의존 관계 프로세스

-->

<!-- 

    @Component
        - 스프링 빈을 정의하는 가장 일반적인 방법
        - 스프링에서 관리되는 객체임을 표시하기 위해 사용
        - 이 어노테이션이 있으면 스프링 빈으로 자동 등록 된다.
        - @Controller, @Service, @Repository 도 스프링 빈으로 자동 등록된다.

    @Controller
        - Spring MVC(Model, View, Controller)에서 URL 매핑할 때 사용
        - MVC 중 Controller의 역할을 하기 위해 사용되는 어노테이션
        - 이 어노테이션이 있으면 스프링 빈으로 자동 등록 된다. (컴포넌트 스캔)

    @Service
        - 비즈니스 로직 구성요소 (실제 사용되는 코드들?)

    @Repository
        - 데이터베이스에서 데이터에 접근하는 객체의 역할
        - 데이터베이스에 접근하고 도메인 객체를 DB에 저장하고 관리

-->

<!-- 
    @Configuration
        - 자바 컨텍스트 구성
        - @Configuration으로 생성된 클래스는 @Bean으로 빈을 생성할 수 있다.

    @ComponentScan
        - @Configuration에 컴포넌트 스캔을 통해 IoC 컨테이너가 빈의 위치를 인식할 수 있다.

    @Bean
        - 이 어노테이션을 선언하면 스프링 빈으로 등록되는 듯 함
        - Bean 등록을 중복으로 하면 에러가 나는 듯 하다 (@Service 있는데 @Bean 한다든지) (could not be registered. A bean with that name has already been defined in file...)

   -->

import com.hello.spring.file;

@Configuration
@ComponentScan(basePackages="com.hello.spring")
class SpringContext { @Bean ... }

<!-- 
    의존성 주입 어노테이션

    @Autowired
        - 애플리케이션 컨텍스트에서 일치하는 의존관계 검색
        - 일치 항목이 1개 있으면 와이어링 성공
        - 없거나 2개 이상이면 실패
        - 생성자 위에 선언.
        - 스프링이 연관된 객체를 스프링 컨테이너에서 찾아 넣어준다.
        - 이런 식으로 의존 관계를 외부에서 넣어주는 것을 DI, 의존성 주입이라고 한다.

    @Primary
        - 2개 이상일 때도 와이어링 가능

    @Qualifier
        - @Qualifier("클래스명") 형태로 사용@Autowired와 기능은 똑같으나 일치 항목이 2개 이상일 때 사용


-->

<!-- 

    자바 컨텍스트?
        - 뭔가 절차를 하기 위해 주는 정보같은 것들?
        - https://pflb.tistory.com/30

    의존성 주입(DI)
        - Spring 프레임워크는 3가지 핵심 프로그래밍 모델을 지원하고 있는데 그 중 하나가 의존성 주입
        - 외부에서 두 객체 간의 관계를 결정해 주는 디자인 패턴
        - 인터페이스를 사이에 둬서 클래스 레벨에서는 의존관계가 고정되지 않도록 하고 런타임 시 관계를 다이나믹하게 주입하여 유연성을 확보하고 결합도를 낮출 수 있게 한다.
        - 한 객체가 다른 객체를 사용할 때 의존성이 있다고 한다.

    스프링은 스프링 컨테이너에 스프링 빈을 등록할 때 기본적으로 싱글톤으로 등록한다. (유일하게 하나만 등록해서 공유)
        따라서, 같은 스프링 빈이면 같은 인스턴스다.

-->

<!-- 
    기타

    - XML로 의존성 설정하는 방식도 있는듯
    - 의존성 주입 : 필드주입, setter주입, 생성자주입 방식이 있다.
    - 의존 관계가 실행 중에 동적으로 변하는 경우는 거의 없으므로 생성자 주입 권장
    - @Autowired를 통한 의존성 주입은 스프링이 관리하는 객체에서만 작동, 스프링 빈으로 등록하지 않고 직접 작성한 객체에서는 작동X


 -->